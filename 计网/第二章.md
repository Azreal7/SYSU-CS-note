## 第二章



### Web和HTTP

Web的应用层协议是**超文本传输协议**(HTTP)，其是Web的核心，由两个程序实现：客户程序和服务器程序，而HTTP定义了这些报文的结构和报文交换的方式。

交互过程基本思想：浏览器向服务器发出对界面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。

而HTTP是一个**无状态协议**，即不保存客户的任何信息(若用户短时间内请求同一个对象，服务端还是会对两次请求多作出回应)

#### 非持续连接和持续连接

客户和服务器一般是在很长的时间范围内通信，要**一直保持通信还是每次响应创建通信**是一个重大问题。

##### 非持续连接的HTTP

每个请求/响应经一个单独的TCP连接发送。

从客户请求HTML基本文件到收到整个文件所花费的时间为：两次**往返时间**(RTT) + 传输HTML文件的时间

##### 持续连接的HTTP

缺点：

- 每一个请求多需要在客户和服务器中分配TCP的缓冲区和保持TCP变量，在同时传大量请求时会造成严重负担
- 每个对象都需要额外创建TCP(保证数据隔离)，需要两倍的RTT，时延长

#### HTTP报文格式

分为请求报文和响应报文

##### 请求报文

```http
GET /somedir/page.html HTTP/1.1
Host: www.sth.com
Connection: close
User-agent: Mozilla/5.0
Accept-language:fr
```

第一行为**请求行**，后继为**首部行**。

- Connection：告诉服务器需不需要使用持续连接
- User-agent：知名用户代理，即浏览器类型

##### 响应报文

```http
HTTP/1.1 200 OK
Connection:close
Date:Tue, 18 Aug 2015 15:44:04 GMT
Server:Apache/2.2.3 (CentOS)
Last-Modified:Tue, 18 Aug 2015 15:15:04 GMT
Content-Length:6821
Content-Type:text/html
(data data data)
```

分为三个部分：第一行初始状态行，6个首部行，最后是实体体

初始状态行表示：服务器正在使用HTTP/1.1，且一切正常

```http
200 OK：请求成功
301 Moved Permanently ：对象被永久转移了
400 Bad Request：请求不能被服务器理解
404 Not Found：请求的文档不在服务器上
505 HTTP Version Not Supported：HTTP版本不支持
```

- Connection：告诉客户，发送完报文后关闭TCP连接。

#### cookie

简化服务器设计，可以识别用户。

在用户进行登录后，可以创建该用户的数据集，便于下一次直接使用。

#### Web缓存

当浏览器请求对象时，会创建一个到Web缓存器的TCP连接，顺便将其内容传入缓存中，如果下次再访问时，可以直接通过缓存器返回该对象。大大减少因特网Web流量。

#### 条件GET方法

当客户将内容缓存后，若在服务端上作出了修改，该如何判断副本是否是最新的？

可以在请求报文后面添加一个**"If-Modified-Since"**首部行，使其成为条件GET请求报文。

由于缓存器存储了最后修改日期，因此检查时Web服务器会向缓存器发送一个响应报文："304 Not Modified"来表示并没有修改过，可以直接使用。

### 电子邮件

电子邮件有3个主要组成部分：**用户代理**、**邮件服务器**和**简单邮件传输协议**。

- 用户代理允许用户阅读、恢复、转发、保存和撰写报文
- 邮件服务器是电子邮件体系结构的核心，负责管理和维护发送的报文。邮件发送过程：发送方用户代理->发送方邮件服务器->接收方邮件服务器->接收方邮箱。当接收者从其邮箱读取报文时，邮件服务器就会通过用户名和口令来鉴别。
  - 且发送者的邮箱需要拥有处理错误的能力，若发送者不能成功交付邮件到接收方服务器，发送方的邮件服务器会在一个**报文队列**保存报文并尝试重新发送。

#### SMTP

落后的技术，如果需要后续再补充。



### DNS：因特网的目录服务(Domain Name System 域名系统)

识别主机有两种方式：**主机名**或**IP地址**

DNS是：

- 一个由分层的DNS服务器实现的**分布式数据库**
- 一个使主机能够查询分布式数据库的应用层协议

运作流程如下：

1. 用户主机运行DNS应用的客户端
2. 浏览器从请求URL中抽取主机名，并传入DNS应用的客户端
3. DNS客户向DNS服务器发送包含主机名的请求
4. DNS客户会收到包含主机名IP地址的回答报文

且DNS也提供了以下服务：

- 主机别名：一个DNS可以关联相同主机但是有多个别名的主机名
- 邮件服务器别名：同上
- 负载分配：DNS可以在冗余的服务器之间进行负载分配，使请求平均分在负载服务器中

##### DNS工作原理

DNS是一个庞大的**分布式、层次数据库**。

有三种类型的DNS服务器：根DNS服务器、顶级域（TLD)DNS服务器和权威DNS服务器，这三个服务器互相交互。

- 根DNS服务器：有400多个根名字服务器遍及全世界，根名字服务器提供TLD服务器的IP地址
- 顶级域服务器：提供DNS服务器的IP地址
- 在因特网上的公共可访问主机必须提供可访问的DNS记录，因此权威DNS服务器可以保存这些记录。

在向下查询时，上一层服务器会向下一层询问名字地址，逐层下降。

##### DNS缓存

及缓存地址，太久不用会删除

##### DNS记录和报文

共同实现DNS分布式数据库的所有DNS服务器存储了**资源记录**，提供了主机名到IP地址的映射。

资源记录是包括以下字段的4元组：(Name, Value, Type, TTL)

TTL是记录的生存时间，决定了资源记录应当从缓存中删除的时间。

- Type=A Name为主机名，Value为对应的IP地址。
- Type=NS Name是个域 Value是知道如何获得域中主机IP的权威DNS服务器的主机名
- Type=CNAME Value为Name主机对应的规范主机名，提供主机名对应的规范主机名
- Type=MX Value是别名为Name的邮件服务器规范主机名

### P2P文件分发

P2P体系结构对总是打开的基础设施服务器只有很小的依赖，成对的主机**彼此直接通信**。

#### P2P体系结构的扩展性

考虑一种将一个文件分发给一个固定对等方集合，服务器和主机都与因特网相连。

$u_s$表示服务器接入链路的上载速率，$u_i$表示第i对等方接入链路的上载速率，$d_i$表示第i对等方接入链路的下载速率，F表示被分发的文件的长度，N表示要获得该文件副本的对等方数量。分发时间(distribution time)是对N个对等方得到该文件的副本所需要的时间。

我们先假设客户-服务器体系结构的分发时间为$D_{cs}$,在此结构中，**没有对等方参与来帮助分发文件**。

我们做下观察：

服务器必须向N个对等方传输文件副本，所以需要传输NF比特，分发时间至少为$\frac{NF}{u_s}$

令$d_{min}$表示具有最小下载速率的对等方下载速率，则最小分发时间至少为$\frac{F}{d_{min}}$

因此可以得出：$D_{cs}\geq max\{\frac{NF}{u_s},\frac{F}{d_{min}}\}$

对于足够大的N，分发时间由$\frac{NF}{u_s}$确定，对等方数量越多，时间越高，且为线性增加。

---

接下来对P2P体系结构进行分析，当一个对等方收到某些文件数据时，它能用自己的上载能力重新将数据发给其他对等方。

我们做一下观察：

分发开始，只有服务器具有文件，必须将文件先发给某个对等方一次，最小分发时间至少是$\frac{F}{u_s}$

最低下载速率的对等方不能够以小于$\frac{F}{d_{min}}$的分发时间获得文件

最后，系统总上载能力为服务器的上载速率加上每个单独对等方的上载速率，即$u_{total}=u_s+u_1+...+u_N$，系统必须向N个对等方每个上载F比特，因此总共交付NF比特，最小分发时间至少是$\frac{NF}{u_{total}}$

因此P2P的最小分发时间为$D_{P2P}$,$D_{P2P}\geq max\{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_{total}}\}$

当N急速上升时，$u_{total}$也会迅速上升，使得$D_{P2P}$上升缓慢，因此P2P速度优于客户-服务器结构。